import { Diagram } from '../diagram';
import { MarkdownPostProcessorContext } from 'obsidian';
import { DiagramData } from '../../settings/typing/interfaces';
import hash from 'hash.js';

export abstract class BaseAdapter {
    constructor(protected diagram: Diagram) {}

    abstract initialize(
        el: HTMLElement,
        context?: MarkdownPostProcessorContext
    ): Promise<void>;

    protected async checkForDiagram(element: HTMLElement) {
        const diagram = this.querySelectorWithData(element);

        const svg = diagram?.element.querySelector('svg');
        const img = diagram?.element.querySelector('img');

        if (diagram && (!!svg || !!img)) {
            return diagram;
        }
    }

    /**
     * Searches for a diagram element within the provided container element.
     *
     * This method iterates over the list of supported diagrams and checks if
     * the diagram is enabled. If the diagram is enabled, it searches for an
     * element within the container element that matches the diagram's selector.
     * If an element is found, it returns an object containing the element and
     * the diagram data. Otherwise, it returns null.
     *
     * @param container - The container element to search for the diagram.
     * @returns An object containing the diagram element and the diagram data, or
     * null if no diagram is found.
     */
    protected querySelectorWithData(
        container: HTMLElement
    ): { diagram: DiagramData; element: HTMLElement } | null {
        for (const diagram of this.diagram.plugin.settings.supported_diagrams) {
            if (!diagram.on) {
                continue;
            }

            const element: HTMLElement | null = container.matches(
                diagram.selector
            )
                ? container
                : container.querySelector(diagram.selector);
            if (element) {
                return { element, diagram };
            }
        }
        return null;
    }

    protected getElSize(
        el: HTMLElement
    ): { height: number; width: number } | undefined {
        const svg = el.querySelector('svg');
        const img = el.querySelector('img');

        if (svg === null && img === null) {
            return undefined;
        }

        const rect = img
            ? img.getBoundingClientRect()
            : el.getBoundingClientRect();
        return {
            width: rect.width,
            height: rect.height,
        };
    }

    /**
     * Generates a unique ID for a diagram.
     *
     * The ID is generated by encoding the diagram's name, start and end line
     * numbers as a UTF-8 string, and then hashing it using the SHA-256
     * algorithm. The hash is then concatenated with the current file's
     * modification time (in seconds since the Unix epoch) to produce a unique
     * identifier.
     *
     * @param lineStart - The starting line number of the code block containing
     * the diagram.
     * @param lineEnd - The ending line number of the code block containing the
     * diagram.
     * @param diagram - The diagram data object.
     * @returns A string representing the unique ID of the diagram.
     */
    protected async genID(
        lineStart: number,
        lineEnd: number,
        diagram: DiagramData
    ): Promise<string> {
        const preId = `${diagram.name}:${lineStart}-${lineEnd}`;
        const hashed_data = hash.sha256().update(preId).digest('hex');
        const ctime = this.diagram.plugin.context.view?.file?.stat.ctime ?? 0;
        return `id-${ctime}-${hashed_data}`;
    }

    protected sourceExtractionWithContext(
        el: HTMLElement,
        contextData: {
            contextElement: HTMLElement;
            context: MarkdownPostProcessorContext;
        }
    ):
        | { source: 'No source available'; lineStart: 0; lineEnd: 0 }
        | {
              source: string;
              lineStart: number;
              lineEnd: number;
          } {
        const sectionsInfo = contextData.context.getSectionInfo(
            contextData.contextElement
        );

        if (!sectionsInfo) {
            return {
                source: 'No source available',
                lineStart: 0,
                lineEnd: 0,
            };
        }

        const { lineStart: ls, lineEnd: le, text } = sectionsInfo;
        const lineStart = ls;
        const lineEnd = le;
        const lines = text.split('\n');
        const source = lines.slice(lineStart, lineEnd + 1).join('\n');

        return {
            source: source,
            lineStart: lineStart,
            lineEnd: lineEnd,
        };
    }

    protected sourceExtractionWithoutContext(el: HTMLElement):
        | {
              source: 'No source available';
              lineStart: 0;
              lineEnd: 0;
          }
        | { source: any; lineStart: any; lineEnd: any } {
        const e = this.diagram.plugin.context.view?.editor as unknown as any;
        const startPos = e.cm.posAtDOM(el.parentElement);

        if (!startPos) {
            return {
                source: 'No source available',
                lineStart: 0,
                lineEnd: 0,
            };
        }

        const data = this.diagram.plugin.context.view?.editor
            .getValue()
            .slice(startPos);
        const source = data?.match(/^"?(```.+?```)/ms)?.[1] ?? 'No source';
        const endPos = startPos + source.length;
        const lineStart = e.cm.state.doc.lineAt(startPos).number;
        const lineEnd = e.cm.state.doc.lineAt(endPos).number;

        return {
            source: source,
            lineStart: lineStart,
            lineEnd: lineEnd,
        };
    }

    initDiagramSize(el: HTMLElement): boolean {
        const diagramOriginalSize = this.getElSize(el);

        if (!diagramOriginalSize) {
            return false;
        }
        let expandedWidth, expandedHeight, foldedWidth, foldedHeight;

        if (this.diagram.plugin.settings.preserveDiagramOriginalSize) {
            expandedWidth = diagramOriginalSize.width;
            expandedHeight = diagramOriginalSize.height;
            foldedWidth = diagramOriginalSize.width / 2;
            foldedHeight = diagramOriginalSize.height / 2;
        } else {
            expandedWidth = parseInt(this.diagram.plugin.settings.diagramExpanded.width, 10);
            expandedHeight = parseInt(this.diagram.plugin.settings.diagramExpanded.height, 10);
            foldedWidth = parseInt(this.diagram.plugin.settings.diagramFolded.width, 10);
            foldedHeight = parseInt(this.diagram.plugin.settings.diagramFolded.height, 10);
        }

        this.diagram.size = {
            expanded: {
                width: expandedWidth,
                height: expandedHeight,
            },
            folded: {
                width: foldedWidth,
                height: foldedHeight,
            },
        };

        return true;
    }

    async createDiagramWrapper(
        diagram: { diagram: DiagramData; element: HTMLElement },
        sourceData: {
            source: string;
            lineStart: number;
            lineEnd: number;
        }
    ): Promise<HTMLElement> {
        const container = document.createElement('div');
        const el = diagram.element;

        container.addClass('diagram-container');
        el.parentNode?.insertBefore(container, el);
        container.appendChild(el);

        this.diagram.updateDiagramSizeBasedOnStatus(container);

        container.id = await this.genID(
            sourceData.lineStart,
            sourceData.lineEnd,
            diagram.diagram
        );
        container.toggleClass(
            'folded',
            this.diagram.plugin.settings.foldByDefault
        );

        container.setAttribute('tabindex', '0');

        return container;
    }

    protected prepareDiagramElement(el: HTMLElement): boolean {
        if (!el.parentElement) {
            return false;
        }
        if (el.parentElement.hasClass('diagram-container')) {
            return false;
        }
        if (el.hasClass('diagram-content')) {
            return false;
        }

        el.addClass('diagram-content');

        return true;
    }

    protected postInitDiagram(
        diagram: { diagram: DiagramData; element: HTMLElement },
        container: HTMLElement,
        sourceData: {
            source: string;
            lineStart: number;
            lineEnd: number;
        }
    ): void {
        const el = diagram.element;
        this.diagram.state.initializeContainer(container.id, sourceData.source);

        this.diagram.controlPanel.initialize(container, diagram.diagram);
        this.diagram.events.initialize(container, diagram.diagram);
        this.diagram.contextMenu.initialize(container, diagram.diagram);

        this.diagram.actions.fitToContainer(el, container);
    }
}
