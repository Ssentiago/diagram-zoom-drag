import { Diagram } from '../diagram';
import { MarkdownPostProcessorContext } from 'obsidian';
import { DiagramData } from '../../settings/typing/interfaces';
import hash from 'hash.js';
import { HTMLElementWithCMView } from './typing/interfaces';
import { DiagramSize } from '../state/typing/interfaces';

export abstract class BaseAdapter {
    constructor(protected diagram: Diagram) {}

    abstract initialize(
        el: Element,
        context?: MarkdownPostProcessorContext
    ): Promise<void>;

    protected async isThatADiagram(element: Element) {
        const diagram = this.querySelectorWithData(element);

        const svg = diagram?.element.querySelector('svg');
        const img = diagram?.element.querySelector('img');

        if (diagram && (!!svg || !!img)) {
            return diagram;
        }
    }

    protected querySelectorWithData(
        element: Element
    ): { diagram: DiagramData; element: HTMLElement } | null {
        for (const diagram of this.diagram.plugin.settings.supported_diagrams) {
            if (!diagram.on) {
                continue;
            }

            const diagramElement: HTMLElement | null =
                element.closest(diagram.selector) ||
                element.querySelector(diagram.selector);
            if (diagramElement) {
                return { element: diagramElement, diagram };
            }
        }
        return null;
    }

    protected getElSize(
        el: HTMLElement
    ): { height: number; width: number } | undefined {
        const svg = el.querySelector('svg');
        const img = el.querySelector('img');

        if (svg === null && img === null) {
            return undefined;
        }

        const rect = img
            ? img.getBoundingClientRect()
            : el.getBoundingClientRect();
        return {
            width: rect.width,
            height: rect.height,
        };
    }

    /**
     * Generates a unique ID for a diagram.
     *
     * The ID is generated by encoding the diagram's name, start and end line
     * numbers as a UTF-8 string, and then hashing it using the SHA-256
     * algorithm. The hash is then concatenated with the current file's
     * modification time (in seconds since the Unix epoch) to produce a unique
     * identifier.
     *
     * @param lineStart - The starting line number of the code block containing
     * the diagram.
     * @param lineEnd - The ending line number of the code block containing the
     * diagram.
     * @param diagram - The diagram data object.
     * @returns A string representing the unique ID of the diagram.
     */
    protected async genID(
        lineStart: number,
        lineEnd: number,
        diagram: DiagramData
    ): Promise<string> {
        const preId = `${diagram.name}:${lineStart}-${lineEnd}`;
        const hashed_data = hash.sha256().update(preId).digest('hex');
        const ctime = this.diagram.plugin.context.view?.file?.stat.ctime ?? 0;
        return `id-${ctime}-${hashed_data}`;
    }

    protected sourceExtractionWithContext(
        el: HTMLElement,
        contextData: {
            contextElement: HTMLElement;
            context: MarkdownPostProcessorContext;
        }
    ):
        | { source: 'No source available'; lineStart: 0; lineEnd: 0 }
        | {
              source: string;
              lineStart: number;
              lineEnd: number;
          } {
        const sectionsInfo = contextData.context.getSectionInfo(
            contextData.contextElement
        );

        if (!sectionsInfo) {
            return {
                source: 'No source available',
                lineStart: 0,
                lineEnd: 0,
            };
        }
        const { lineStart: ls, lineEnd: le, text } = sectionsInfo;
        const lineStart = ls + 1;
        const lineEnd = le - 1;
        const lines = text.split('\n');
        const source = lines.slice(lineStart, lineEnd + 1).join('\n');

        return {
            source: source,
            lineStart: lineStart,
            lineEnd: lineEnd,
        };
    }

    protected sourceExtractionWithoutContext(el: HTMLElement): {
        source: string;
        lineStart: number;
        lineEnd: number;
    } {
        const parent = el.parentElement as HTMLElementWithCMView;
        const widgetData = parent.cmView?.deco?.widget;
        if (!widgetData) {
            return {
                source: 'No source available',
                lineStart: 0,
                lineEnd: 0,
            };
        }

        return {
            source: widgetData.code,
            lineStart: widgetData.lineStart,
            lineEnd: widgetData.lineEnd,
        };
    }

    initDiagramSize(el: HTMLElement): DiagramSize | undefined {
        const diagramOriginalSize = this.getElSize(el);

        if (!diagramOriginalSize) {
            return;
        }

        return diagramOriginalSize;
    }

    async createDiagramWrapper(
        diagram: { diagram: DiagramData; element: HTMLElement },
        sourceData: {
            source: string;
            lineStart: number;
            lineEnd: number;
        }
    ): Promise<HTMLElement> {
        const container = document.createElement('div');
        const el = diagram.element;

        container.addClass('diagram-container');
        const renderingMode = this.diagram.plugin.isInPreviewMode
            ? 'preview'
            : 'live-preview';
        container.setAttribute(
            'data-diagram-zoom-drag-rendering-mode',
            `${renderingMode}`
        );
        el.parentNode?.insertBefore(container, el);
        container.appendChild(el);

        container.id = await this.genID(
            sourceData.lineStart,
            sourceData.lineEnd,
            diagram.diagram
        );
        container.setAttribute(
            'data-folded',
            this.diagram.plugin.settings.foldByDefault.toString()
        );

        container.setAttribute('tabindex', '0');

        return container;
    }

    protected prepareDiagramElement(el: HTMLElement): boolean {
        if (!el.parentElement) {
            return false;
        }
        if (el.parentElement.hasClass('diagram-container')) {
            return false;
        }
        if (el.hasClass('diagram-content')) {
            return false;
        }

        el.addClass('diagram-content');

        return true;
    }

    protected postInitDiagram(
        diagram: { diagram: DiagramData; element: HTMLElement },
        container: HTMLElement,
        sourceData: {
            source: string;
            lineStart: number;
            lineEnd: number;
        },
        size: DiagramSize
    ): void {
        const el = diagram.element;
        this.diagram.state.initializeContainer(
            container.id,
            sourceData.source,
            size
        );

        this.diagram.controlPanel.initialize(container, diagram.diagram);
        this.diagram.events.initialize(container, diagram.diagram);
        this.diagram.contextMenu.initialize(container, diagram.diagram);
        this.diagram.updateDiagramSizeBasedOnStatus(container);
        this.diagram.actions.fitToContainer(el, container);
    }
}
